---
title: "tumor_airway_comparisons_combined_script"
output: html_document
date: "2024-10-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This script will include all steps in the "main pipeline" part of my thesis project. This includes differential analysis of the reference airway Current vs never smoker dataset (A1, GSE63127), differential expression analysis of the TCGA-LUAD lung adenocarcinoma expression and methylation datasets, and the reference "persistent" airway current vs former vs never smoker dataset (A2, GSE7895). This includes all normalization, quality control, and filtering steps.

Notes: 
- I will opt to keep all genes with FDR < 0.05 until the step with filtering and dataset comparisons.

# Loading libraries
```{r}
library(EnhancedVolcano, verbose = FALSE)
library(GEOquery, verbose = FALSE)
library(limma, verbose = FALSE)
library(umap, verbose = FALSE)
library(dplyr, verbose = FALSE)
```


# 1. Differential expression analysis of reference airway current vs never smoker dataset (A1, GSE63127)

## 1.1 Loading dataset
```{r}

# Version info: R 4.2.2, Biobase 2.58.0, GEOquery 2.66.0, limma 3.54.0
################################################################
#   Differential expression analysis with limma


# load series and platform data from GEO (date: 2024/10/15)
gset <- getGEO("GSE63127", GSEMatrix =TRUE, AnnotGPL=TRUE)
if (length(gset) > 1) idx <- grep("GPL570", attr(gset, "names")) else idx <- 1
gset <- gset[[idx]]

# make proper column names to match toptable 
fvarLabels(gset) <- make.names(fvarLabels(gset))

# group membership for all samples
gsms <- paste0("X00100011111X00000000000X00000X000000000000X000X00",
               "XX00X0XXXXXXXXX1111111111111111111111X111X11111111",
               "XXXX1XXXXXXXXXXXXXXXXXXXXXXXX001000000010100111111",
               "01110111110011111001110011101011111001110101100011",
               "111111111111111111111111111111")
sml <- strsplit(gsms, split="")[[1]]

# filter out excluded samples (marked as "X")
sel <- which(sml != "X")
sml <- sml[sel]
gset <- gset[ ,sel]

gset <- gset[complete.cases(exprs(gset)), ] # skip missing values
length(sml) # 182 samples

```

## 1.2 Quality control checks and normalization 
2024/11/07: I am going to try doing this without the quantile normalization to see whether it's still okay
```{r}

## Make histograms and boxplots to check if the data is log-transformed and needs quantile normalization ##
hist(as.matrix(exprs(gset))) # skewed left, needs log2 transform
boxplot(exprs(gset)) # scary-looking
max(exprs(gset)) # 136808
min(exprs(gset)) # 0.0657913
# Should do log2 and quantile normalization

## log2 and Quantile normalization ##
exprs(gset) <- log2(exprs(gset)+1)
##exprs(gset) <- normalizeBetweenArrays(exprs(gset)) # quantile normalization: no longer doing this for now


hist(as.matrix(exprs(gset))) # much better
boxplot(exprs(gset)) # Look reasonable
min(exprs(gset)) 
max(exprs(gset)) 

```

## 1.3 Checking and correcting batch effect / sources of variation

### 1.3.1: Download and clean up the phenotypic information table from the dataset
```{r}
# assign samples to groups and set up design matrix
gs <- factor(sml)
groups <- make.names(c("non-smoker","smoker"))
levels(gs) <- groups
gset$group <- gs

phenotypic_data <- pData(gset)  # Extract phenotypic data

# The phenotypic data is terrible.
# This is filtered down to the samples that were included.
# I will first try to clean up the phenotypic data.
head(phenotypic_data)

# So I think the features I want to keep will be:
# Dates of submission/updates etc, sex, ethnicity, smoking status
# Keep the columns that might contain data of interest, which will need to be cleaned up.

# List of column names I want to keep and clean up into usable labels
columns_to_find <- c("geo_accession","status","submission_date","last_update_date","characteristics_ch1","characteristics_ch1.1","characteristics_ch1.2","characteristics_ch1.3","age:ch1","cilia length:ch1","ethnic group:ch1","ethnicity:ch1","serum 25-oh-d:ch1","sex:ch1","smoking status:ch1","group")

# Get the column indexes
indexes <- sapply(columns_to_find, function(col_name) which(names(phenotypic_data) == col_name))
indexes <- unlist(indexes)

phenotypic_data <- phenotypic_data[,c(indexes)]

# Now I need to parse out sex, ethnicity, smoking status, and age, vitamin D, pack years.

#Rename "group" as "smoking status"
names(phenotypic_data)[16] <- "smoking_status"

## Grabbing ethnicity values from the columns ##
# Initialize a new column "ethnicity" with NA values
phenotypic_data$ethnicity <- NA

# Function to find 'eth' in a row and return the corresponding value
find_ethnicity <- function(row) {
  eth_column <- which(grepl('eth', row))
  if (length(eth_column) > 0) {
    return(row[eth_column])
  } else {
    return(NA)
  }
}
# Apply the function row-wise to populate the "ethnicity" column
phenotypic_data$ethnicity <- apply(phenotypic_data, 1, find_ethnicity)

## Grabbing sex values from the columns ##
# Initialize a new column "sex" with NA values
phenotypic_data$sex <- NA

# Function to find 'sex' in a row and return the corresponding value
find_sex <- function(row) {
  sex_column <- which(grepl('sex', row))
  if (length(sex_column) > 0) {
    return(row[sex_column])
  } else {
    return(NA)
  }
}
# Apply the function row-wise to populate the "sex" column
phenotypic_data$sex <- apply(phenotypic_data, 1, find_sex)


## Grabbing pack_years values from the columns ##
# Initialize a new column "pack_years" with NA values
phenotypic_data$pack_years <- NA

# Function to find 'pack_years' in a row and return the corresponding value, but just the first instance
find_pack_years <- function(row) {
  pack_years_column <- which(grepl('pack', row))
  if (length(pack_years_column) > 0) {
    return(row[pack_years_column[1]])
  } else {
    return(NA)
  }
}
# Apply the function row-wise to populate the "pack_years" column
phenotypic_data$pack_years <- apply(phenotypic_data, 1, find_pack_years)
#unlist the column
phenotypic_data$pack_years <- unlist(phenotypic_data$pack_years )



## Grabbing age values from the columns ##
# Initialize a new column "age" with NA values
phenotypic_data$age <- NA

# Function to find 'age' in a row and return the corresponding value
find_age <- function(row) {
  age_column <- which(grepl('age', row))
  if (length(age_column) > 0) {
    return(row[age_column])
  } else {
    return(NA)
  }
}
# Apply the function row-wise to populate the "age" column
phenotypic_data$age <- apply(phenotypic_data, 1, find_age)


## Grabbing vitamin_d values from the columns ##
# Initialize a new column "vitamin_d" with NA values
phenotypic_data$vitamin_d <- NA

# Function to find 'vitamin_d' in a row and return the corresponding value, first instance
find_vitamin_d <- function(row) {
  vitamin_d_column <- which(grepl('vitamin', row))
  if (length(vitamin_d_column) > 0) {
    return(row[vitamin_d_column[1]])
  } else {
    return(NA)
  }
}
# Apply the function row-wise to populate the "vitamin_d" column
phenotypic_data$vitamin_d <- apply(phenotypic_data, 1, find_vitamin_d)

## Grabbing vitamin_d values from the columns ##
# Initialize a new column "vitamin_d" with NA values
phenotypic_data$vitamin_d <- NA

# Function to find 'vitamin_d' in a row and return the corresponding value, first instance
find_vitamin_d <- function(row) {
  vitamin_d_column <- which(grepl('vitamin', row))
  if (length(vitamin_d_column) > 0) {
    return(row[vitamin_d_column[1]])
  } else {
    return(NA)
  }
}
# Apply the function row-wise to populate the "vitamin_d" column
phenotypic_data$vitamin_d <- apply(phenotypic_data, 1, find_vitamin_d)

## Grabbing cilia values from the columns ##
# Initialize a new column "cilia_length" with NA values
phenotypic_data$cilia_length <- NA

# Function to find 'cilia' in a row and return the corresponding value, first instance
find_cilia <- function(row) {
  cilia_column <- which(grepl('cilia', row))
  if (length(cilia_column) > 0) {
    return(row[cilia_column[1]])
  } else {
    return(NA)
  }
}
# Apply the function row-wise to populate the "cilia" column
phenotypic_data$cilia_length <- apply(phenotypic_data, 1, find_cilia)



## Now cut out the messy columns
phenotypic_data <- phenotypic_data[,-c(5:15)]

## Remove unnecessary prefix info
phenotypic_data$ethnicity <- gsub(".*: ", "", phenotypic_data$ethnicity )
phenotypic_data$age <- gsub(".*: ", "", phenotypic_data$age)
phenotypic_data$sex <- gsub(".*: ", "", phenotypic_data$sex)
phenotypic_data$vitamin_d <- gsub(".*: ", "", phenotypic_data$vitamin_d)
phenotypic_data$cilia_length <- gsub(".*: ", "", phenotypic_data$cilia_length)

phenotypic_data$pack_years<- gsub(".*, ", "", phenotypic_data$pack_years)
phenotypic_data$pack_years<- gsub("pack-years", "", phenotypic_data$pack_years)


# Reformat the submission dates to be sortable

phenotypic_data <- phenotypic_data %>%
  mutate(submission_date = ifelse(submission_date == "Dec 20 2012", "2012-12-20", submission_date)) %>%
  mutate(submission_date = ifelse(submission_date == "Jan 03 2008", "2008-01-08", submission_date)) %>%
  mutate(submission_date = ifelse(submission_date == "Jan 31 2013", "2013-01-31", submission_date)) %>%
  mutate(submission_date = ifelse(submission_date == "Jun 03 2010", "2010-06-03", submission_date)) %>%
  mutate(submission_date = ifelse(submission_date == "Jun 13 2008", "2008-06-13", submission_date)) %>%
  mutate(submission_date = ifelse(submission_date == "May 17 2007", "2007-05-17", submission_date)) %>%
  mutate(submission_date = ifelse(submission_date == "Nov 08 2013", "2013-11-08", submission_date)) %>%
  mutate(submission_date = ifelse(submission_date == "Nov 10 2014", "2014-11-10", submission_date))
```


### 1.3.2: Plot PCA and use phenotypic information to look for sources of batch effect/variation, and correct for these with ComBat
```{r}

# assign samples to groups and set up design matrix
gs <- factor(sml)
groups <- make.names(c("non-smoker","smoker"))
levels(gs) <- groups
gset$group <- gs


## Plot PCA 1 ##
colz <- as.numeric(as.factor(gs)) # Get color values from group
plotMDS(exprs(gset),
        gene.selection = "common",
        main = "PCA for CS vs NS GSE63127",
        col = colz,
        pch = 1
)
        
## We have 4 definite clusters that are not based on smoking status. 
## As such, it is a good idea to check the table of sample phenotypic information to look for sources of variation between samples.


pointz <- as.numeric(as.factor(phenotypic_data$submission_date<= "2010-06-03")) # Get point shape values from date of submission: split into 2010 and earlier, post-2010]

## Plot PCA with date information##
plotMDS(exprs(gset),
        gene.selection = "common",
        main = "PCA for CS vs NS GSE63127",
        col = colz, # Colors smokers red and nonsmokers black
        pch = pointz
        #labels = gset$group
)

# Clearly the source of batch effect in PC1 is submission date post-2010.
# Note: I found that the split was at 2010 by doing a bit of playing around with other clustering methods, not shown here.

# First batch correction (submission date)
library(sva)
library(limma)

# Making a batch vector
submission_post_2010_batch <- ifelse(phenotypic_data$submission_date < as.Date("2012-01-01"), 1, 2)

# Adjust the expression matrix for submission date batch effect
exprs_matrix_combat <- ComBat(dat=exprs(gset), batch=submission_post_2010_batch, mod=NULL, par.prior=TRUE, prior.plots=FALSE)

## Plot PCA for expression values after first batch correction ##
date_corrected_PCA <- plotMDS(exprs_matrix_combat,
        gene.selection = "common",
        main = "PCA for CS vs NS GSE63127, corrected for submission date",
        col = colz, # Colors smokers red and nonsmokers black
        pch = pointz

)

## Some evidence that second source of variation could be due to sex (but only 11/182 samples have sex labels):
plotMDS(exprs_matrix_combat,
        gene.selection = "common",
        main = "PCA for CS vs NS GSE63127, corrected for submission date",
        col = colz, # Colors smokers red and nonsmokers black
        #pch = pointz2 # Using separate shapes for all submission dates
        labels = phenotypic_data$sex
)
## Samples are divided by sex, but 11/182 samples is not enough to draw a conclusion here.

## Second correction for unknown source of variation using ComBat: ##

# Assign batch labels based on the first dimension from MDS (equivalent to PC1), since the dividing line for the batches lies at 0
unknown_batch_labels <- ifelse(date_corrected_PCA$x < 0, 1, 2)

# Do a second batch correction
exprs_matrix_combat_2 <- ComBat(dat=exprs_matrix_combat, batch=unknown_batch_labels, mod=NULL, par.prior=TRUE, prior.plots=FALSE)

# View PCA plot
plotMDS(exprs_matrix_combat_2,
        gene.selection = "common",
        main = "PCA for CS vs NS GSE63127 after 2 ComBat corrections",
        col = colz, # Colors smokers red and nonsmokers black
        pch = pointz
        #labels = gset$group
)

## Now PC1 corresponds quite well to smoking status after the two ComBat corrections.


```

## 1.4 Differential expression analysis (limma with vooma)
```{r}

# Finish setting up the design matrix
design <- model.matrix(~group + 0, gset)
colnames(design) <- levels(gs)


## Crucial bit: Replace the expression values in gset with the batch corrected ones ##
exprs(gset) <- as.matrix(exprs_matrix_combat_2)

# calculate precision weights and show plot of mean-variance trend
v <- vooma(gset, design, plot=T)
# OR weights by group
# v <- voomaByGroup(gset, group=groups, design, plot=T, cex=0.1, pch=".", col=1:nlevels(gs))
v$genes <- fData(gset) # attach gene annotations

# fit linear model
fit  <- lmFit(v)

# set up contrasts of interest and recalculate model coefficients
cts <- paste(groups[2], groups[1], sep="-")
cont.matrix <- makeContrasts(contrasts=cts, levels=design)
fit2 <- contrasts.fit(fit, cont.matrix)

# compute statistics and table of top significant genes
fit2 <- eBayes(fit2, 0.01)
tT <- topTable(fit2, adjust="fdr", sort.by="B", number=Inf)

tT <- subset(tT, select=c("ID","Gene.symbol","logFC","adj.P.Val"))

```

## 1.5 Basic filtering of DEGs (unlabelled, duplicates, FDR < 0.05)
```{r}

# Now I want to filter unlabelled genes, duplicate genes, and adj.P.Val < 0.05
GSE63127_CS_NS_GEO2R_limma_all <- tT %>%
  filter(Gene.symbol != "") %>% # Remove blank gene symbols
#  filter(adj.P.Val <= 0.05) %>% # Remove FDR > 0.05 genes
  group_by(Gene.symbol) %>%
  slice_min(adj.P.Val, with_ties = TRUE) %>% 
  # For probesets mapping to same gene, keep one with lowest FDR. Keep ties for now to check later.
  ungroup()
head(GSE63127_CS_NS_GEO2R_limma_all)

GSE63127_CS_NS_GEO2R_limma_sig <- GSE63127_CS_NS_GEO2R_limma_all %>%
  filter(adj.P.Val <= 0.05) # Remove FDR > 0.05 genes
head(GSE63127_CS_NS_GEO2R_limma_sig)

# Checking for ties
ties <- GSE63127_CS_NS_GEO2R_limma_sig %>%
  group_by(Gene.symbol) %>%
  filter(n() > 1) %>%
  ungroup()
print(ties) # No ties

nrow(GSE63127_CS_NS_GEO2R_limma_sig)

```

## 1.8 Visualization of DEGs (volcano plot)
```{r, fig.width=10, fig.height=8}

log2FC_cutoff1 <- 0.2

v1 <- EnhancedVolcano::EnhancedVolcano(
  toptable = GSE63127_CS_NS_GEO2R_limma_all,
  lab = GSE63127_CS_NS_GEO2R_limma_all$Gene.symbol,
  x = "logFC", # "mean difference" is estimate here
  y = "adj.P.Val", 
 # pCutoffCol = 'min_smoothed_fdr',
  xlab = "log2FC",
  ylab = "-log10(FDR)",
  title = "A1 DEGs",
  subtitle = paste0("log2FC cutoff: ", log2FC_cutoff1),
  caption = paste0("Total = ", nrow(GSE63127_CS_NS_GEO2R_limma_sig[abs(GSE63127_CS_NS_GEO2R_limma_sig$logFC)>log2FC_cutoff1,]), " significant DEGs above log2FC cutoff"),
  col = c("grey30", "mediumpurple2", "royalblue", "orange2"),
  legendPosition = "bottom",
  labSize = 4,
  max.overlaps = 5,
  drawConnectors = TRUE,
  arrowheads = FALSE,
  pCutoff = 0.05,
  FCcutoff = log2FC_cutoff1,
  gridlines.minor = FALSE,
  gridlines.major = FALSE,
  xlim = c(-3, 6)
)

v1
```


## 1.7 Save outputs
```{r}

# Change date suffix as appropriate if changes are made
#write.table(GSE63127_CS_NS_GEO2R_limma_sig, "../2_Outputs/GSE63127_CS_NS_GEO2R_limma_sig_20241107.txt", sep = '\t')

```

## 1.8 Extra checks
2024/11/07: Comparing the DEGs list when quantile normalization is used vs not used:
```{r}
GSE63127_CS_NS_GEO2R_limma_sig_quantile <- read.table("../2_Outputs/GSE63127_CS_NS_GEO2R_limma_sig_20241016.txt", header = TRUE)
GSE63127_CS_NS_GEO2R_limma_sig_no_quantile <- GSE63127_CS_NS_GEO2R_limma_sig

# Compare results
library(VennDiagram)
venn <- venn.diagram(
  list(
    DEGs_no_quantile = GSE63127_CS_NS_GEO2R_limma_sig_no_quantile$Gene.symbol,
    DEGs_quantile = GSE63127_CS_NS_GEO2R_limma_sig_quantile$Gene.symbol
  ),
  filename = NULL
)
# Display the diagram
grid.newpage()
grid.draw(venn)

```
The lists agree quite well. The list without quantile normalization is larger. Quantile normalization could be over-normalization and mask some variation. The PCA plots still look good without quantile normalization. I will elect to go forward without quantile normalization. I will have to apply the same to all the other airway datasets for the meta-analysis bit.


##########

# 2. Differential expression analysis of TCGA-LUAD tumor vs normal tissue (T-E)

## 2.1 Loading dataset, formatting as tumor-normal pairs
```{r}

library(TCGAbiolinks)
library(SummarizedExperiment)
library(dplyr)

query <- GDCquery(project = "TCGA-LUAD",
                  data.category = "Transcriptome Profiling",
                  data.type = "Gene Expression Quantification",
                  sample.type = c("Primary Tumor", "Solid Tissue Normal"),
                  workflow.type = "STAR - Counts")

GDCdownload(query)

data <- GDCprepare(query)

counts <- as.data.frame(assay(data))  # Extracting the count matrix (these are supposedly raw counts)
head(counts)  # Viewing the first few rows (genes) and columns (samples)

gene_info <- as.data.frame(rowData(data))
head(gene_info)  # Preview the first few genes and their annotations

sample_info <- as.data.frame(colData(data))
head(sample_info)  # Preview sample metadata

table(sample_info$sample_type)  # Summarize sample types (Tumor vs. Normal)

# Extract just the normal sample info
sample_info_normal <- sample_info[sample_info$definition=="Solid Tissue Normal",]

# Look for tumor samples with normal matches from same patients
sample_info_tumor <- sample_info %>%
  filter(patient %in% sample_info_normal$patient) %>%
  filter(definition == "Primary solid Tumor")

# The tumor list is longer -- check out duplicate patient IDs in this list
sample_info_tumor_dups <- sample_info_tumor %>%
  group_by(patient) %>%
  filter(n() > 1) %>%
  ungroup()

unique(sample_info_tumor_dups$patient) # There are 6 patients with multiple tumor samples
sample_info_tumor_dups_FFPE <- sample_info_tumor_dups[sample_info_tumor_dups$is_ffpe,] # OK the difference is the FFPE status.
# It seems these are the only 6 patients in the group who have FFPE samples available.

# I guess I will make the decision to keep the 6 FFPE samples regardless. Not sure if that's the right choice but I'll do it for now.

# Get the non-FFPE duplicate patient sample info
sample_info_tumor_dups_non_FFPE <- sample_info_tumor_dups[!sample_info_tumor_dups$is_ffpe,]
# Remove these IDs from the main tumor sample info
sample_info_tumor <- sample_info_tumor %>% filter(! barcode %in% sample_info_tumor_dups_non_FFPE$barcode)

# There is 1 normal sample with no matching tumor sample it seems, so remove that
sample_info_normal <- sample_info_normal %>% filter(patient != "TCGA-44-6144")

# Make the matched tumor-normal sample table
sample_info_matched_T_NM <- rbind(sample_info_tumor, sample_info_normal)[order(c(seq_len(nrow(sample_info_tumor)), seq_len(nrow(sample_info_normal)))), ]
sample_info_matched_T_NM <- sample_info_matched_T_NM %>% 
  dplyr::select(-treatments) %>% # Removing treatments column since it is in the form of a list and has no info
  arrange(., sample_type_id) %>% # First sort by tumor vs normal
  arrange(., patient) # arrange by patient to get the tumor normal pairs

## Modifying the counts table for tumor-normal matched data ##

# Keep the counts columns of sample labels that are in the T-NM matched info
sample_barcodes <- as.character(sample_info_matched_T_NM$barcode)
counts_matched_T_NM <- counts %>%
  dplyr::select(all_of(sample_barcodes))

# Rename with sample label instead of sample barcode
names(counts_matched_T_NM) <- sample_info_matched_T_NM$sample

```

## 2.2.1 Quality control checks
```{r}

library(dplyr)
library(edgeR)

# Checking distribution of the whole counts table
hist(as.matrix(counts_matched_T_NM)) # whoa
hist(log2(as.matrix(counts_matched_T_NM))) # Still not normal at all

# Checking distribution of just tumor samples
counts_matched_T <- counts_matched_T_NM %>%
  dplyr::select(seq(1, ncol(counts_matched_T_NM), by = 2))
hist(log2(as.matrix(counts_matched_T))) # Equally bad distribution, why is it the same though??

# Checking distribution of just normal samples
counts_matched_NM <- counts_matched_T_NM %>%
  dplyr::select(seq(2, ncol(counts_matched_T_NM), by = 2))
hist(log2(as.matrix(counts_matched_NM))) # Equally bad distribution, why is it the same though????


boxplot(counts_matched_T_NM) # Boxplots for all counts looks crazy
# boxplot(counts_matched_T) # Boxplots for just tumors looks crazy
# boxplot(counts_matched_NM) # Boxplots for just normals looks crazy

## PCA to check for tumor-normal separation
colz <- as.numeric(as.factor(rep(c(0,1), length(counts_matched_T_NM)/2))) # Get color values from group
plotMDS(counts_matched_T_NM,
        gene.selection = "common",
        main = "PCA for TCGA-LUAD expression",
        col = colz,
        pch = 1
)
# Separate but not very good separation, 1 definite outlier.
# To find the outlier, plotting PCA with sample names
plotMDS(counts_matched_T_NM,
        gene.selection = "common",
        main = "PCA for TCGA-LUAD expression",
        col = colz
        #pch = 1
)

# Checking out this outlier, TCGA-38-4626-01A
hist(log2(counts_matched_T_NM$`TCGA-38-4626-01A`)) # Not obvious why it's an outlier, but must somehow be really normal-like?

##  Making a dendrogram to see if the same outliers are found
sample_dist <- dist(t(counts_matched_T_NM))  # Transpose the matrix to calculate distances between samples
hc <- hclust(sample_dist) #Perform hierarchical clustering
plot(hc, main = "Dendrogram of Samples", xlab = "", sub = "", cex = 0.8) # Plot the dendrogram

```

## 2.2.2 Acting on quality control checks
```{r}
# Remove the 1 most obvious outlier and its pair:

# TCGA-38-4626-01A, TCGA-38-4626-11A

counts_matched_T_NM <- counts_matched_T_NM %>% dplyr::select(-c("TCGA-38-4626-01A","TCGA-38-4626-11A"))

# counts_matched_T_NM <- counts_matched_T_NM %>% dplyr::select(-c("TCGA.38.4626.01A","TCGA.38.4626.11A"))
# Version after reading it in

## PCA to check for tumor-normal separation with outlier removed
colz2 <- as.numeric(as.factor(rep(c(0,1), length(counts_matched_T_NM)/2))) # Get color values from group
plotMDS(counts_matched_T_NM,
        gene.selection = "common",
        main = "PCA for TCGA-LUAD expression after outlier removal",
        col = colz2,
        pch = 1
)

```

The matrices have messy boxplots and histograms, but since I am using the signed-rank test, it does not suppose require normally distributed data, so I have decided to go with this raw counts matrix for now.

## 2.3 Differential expression analysis using signed-rank test, and filter to FDR < 0.05

DGE/DEG analysis is based on a recent paper: Li et al. Genome Biology (2022) 23:79
Source code: https://github.com/xihuimeijing/DEGs_Analysis_FDR/blob/main/scripts/DEGs.R
Accessed 2023/08/26

Tutorial: https://rpubs.com/LiYumei/806213
Accessed 2023/08/31

Unlike the tutorial, here I perform a signed-rank test rather than a rank-sum test, as the samples are not independent (they are matched tumor and normal samples).

```{r}

library(edgeR)

# Make DGElist
readCount <- counts_matched_T_NM
conditions <- factor(matrix(c(rep(c(1,2),length(counts_matched_T_NM)/2)), ncol=1)) # Columns are alternating tumor-normal pairs
y <- DGEList(counts=readCount,group=conditions)

#Filter out genes with very low counts using the filterByExpr function (default)
keep <- filterByExpr(y)
y <- y[keep,,keep.lib.sizes=FALSE]

#Perform TMM normalization and transfer to CPM (Counts Per Million)
y <- calcNormFactors(y,method="TMM")
count_norm=cpm(y)
count_norm<-as.data.frame(count_norm)

#Unlike the tutorial, here I specify "paired = TRUE" to ensure the test is a signed-rank test as opposed to a rank-sum test.
pvalues <- sapply(1:nrow(count_norm),function(i){
  data<-cbind.data.frame(gene=as.numeric(t(count_norm[i,])),conditions)
  p=wilcox.test(gene~conditions, data, paired = TRUE,)$p.value
  return(p)
})

#Return false discovery rate - corrected P-values
fdr=p.adjust(pvalues,method = "fdr")

#Calculate log fold change
tumor_indexes = seq(1, ncol(count_norm), by = 2)
normal_indexes = seq(2, ncol(count_norm), by = 2)

tumor_values=count_norm[,tumor_indexes]
normal_values=count_norm[,normal_indexes]
foldChanges=log2(rowMeans(tumor_values, na.rm = TRUE)/rowMeans(normal_values, na.rm = TRUE))

#Output results to a unified table!
DGE_LUAD_T_NM_signed_rank <-data.frame(log2foldChange=foldChanges, pValues=pvalues, FDR=fdr)
rownames(DGE_LUAD_T_NM_signed_rank)=rownames(count_norm)
DGE_LUAD_T_NM_signed_rank=na.omit(DGE_LUAD_T_NM_signed_rank)


### Replace ensembl IDs with gene names
# Filter gene info to the ensembl IDs we want to replace
gene_info_DEGs <- gene_info %>%
  filter(gene_id %in% rownames(DGE_LUAD_T_NM_signed_rank))

# Sort both lists by the ensembl ID
gene_info_DEGs <- gene_info_DEGs %>% arrange(., gene_id)
DGE_LUAD_T_NM_signed_rank<- DGE_LUAD_T_NM_signed_rank %>% arrange(., rownames(.))

# Add gene names to the DEGs list, remove the rownames
DGE_LUAD_T_NM_signed_rank$Gene <- gene_info_DEGs$gene_name
rownames(DGE_LUAD_T_NM_signed_rank) <- NULL


### Filter to genes below FDR < 0.05 ###
fdrThres=0.05
DGE_LUAD_T_NM_signed_rank_sig <- DGE_LUAD_T_NM_signed_rank[DGE_LUAD_T_NM_signed_rank$FDR<fdrThres,]

nrow(DGE_LUAD_T_NM_signed_rank_sig) # 13465 (2024/11/07)

```

## 2.5 Visualization of DEGs (volcano plot)
```{r, fig.width=10, fig.height=6}
log2FC_cutoff2 <- 1

v2 <- EnhancedVolcano::EnhancedVolcano(
  toptable = DGE_LUAD_T_NM_signed_rank,
  lab = DGE_LUAD_T_NM_signed_rank$Gene,
  x = "log2foldChange",
  y = "FDR", 
 # pCutoffCol = 'min_smoothed_fdr',
  xlab = "log2FC",
  ylab = "-log10(FDR)",
  title = "TE DEGs",
  subtitle = paste0("log2FC cutoff: ", log2FC_cutoff2),
  caption = paste0("Total = ", nrow(DGE_LUAD_T_NM_signed_rank_sig[abs(DGE_LUAD_T_NM_signed_rank_sig$log2foldChange)>log2FC_cutoff2,]), " significant DEGs above log2FC cutoff"),
  col = c("grey30", "mediumpurple2", "royalblue", "orange2"),
  legendPosition = "bottom",
  labSize = 3,
  max.overlaps = 10,
  drawConnectors = TRUE,
  arrowheads = FALSE,
  pCutoff = 0.05,
  FCcutoff = log2FC_cutoff2,
  gridlines.minor = FALSE,
  gridlines.major = FALSE,
  #xlim = c(-3, 6)
  ylim = c(0,10)
)

v2
```


## 2.6 Extra checks
```{r}
## Checking the distribution of log2FC values to think about cutoffs

hist(DGE_LUAD_T_NM_signed_rank_sig$log2foldChange, breaks = 20) # Looks like a cutoff of 1 would remove a lot
log2FC_cutoff <- 2
nrow(DGE_LUAD_T_NM_signed_rank_sig[abs(DGE_LUAD_T_NM_signed_rank_sig$log2foldChange)>log2FC_cutoff,])

```

## 2.5 Saving outputs
```{r}
# Change date suffix as appropriate if modifications are made
#write.table(DGE_LUAD_T_NM_signed_rank_sig, "../2_Outputs/DGE_LUAD_T_NM_signed_rank_sig_20241107.txt", sep = '\t')
```

#####

# 3. Differential methylation analysis of TCGA-LUAD tumor vs normal tissue (T-E)

I downloaded this level 3 methylation 450k data from cBioPortal, from TCGA Lung Adenocarcinoma (Firehose Legacy)
https://www.cbioportal.org/study/summary?id=luad_tcga
(Accessed 2023/08/29)
Note that this provides gene information but not probe information.
I did a lot of work trying to do the analysis starting from probe level information, but ultimately decided to stick with this.

## 3.1 Loading dataset
```{r}

data_methylation_hm450_tumor <- read.table("../../Former_Smokers_Aim_2/1_TCGA_LUAD_multiomics/0_Unpaired_input_tables/data_methylation_hm450.txt", header=TRUE, fill=TRUE)

data_methylation_hm450_normal <- read.table("../../Former_Smokers_Aim_2/1_TCGA_LUAD_multiomics/0_Unpaired_input_tables/data_methylation_hm450_normals.txt", header=TRUE, fill=TRUE)

```


## 3.2 Formatting dataset 

### 3.2.1 Formatting counts in tumor-normal pairs
```{r}

allIDs_tumor <- colnames(data_methylation_hm450_tumor)
allIDs_normal <- colnames(data_methylation_hm450_normal)

#Listing IDs of tumors that have matched normals by changing the tissue ID to the "tumor" identifier, "01", for matching purposes.
IDs_tumor_with_matches <-gsub(".11",".01", allIDs_normal)

#Make a table of the methylation data for tumor samples only with matching normal data.
#
data_methylation_hm450_tumor_with_matches <- data_methylation_hm450_tumor %>%
  dplyr::select(any_of(IDs_tumor_with_matches))

#Make a table of the methylation data for normal samples only with matching tumor data.
# Note that 3 of the normal samples don't have a matching tumor sample:
#`TCGA.44.2655.01`, `TCGA.44.2659.01`, and `TCGA.44.2662.01` don't exist.
data_methylation_hm450_normal_with_matches <- data_methylation_hm450_normal %>%
  dplyr::select(-c('TCGA.44.2655.11', 'TCGA.44.2659.11','TCGA.44.2662.11'))

#Make a combined table of matched tumor-normal samples.
data_methylation_hm450_tumor_normal_matched <- cbind(data_methylation_hm450_tumor_with_matches, data_methylation_hm450_normal_with_matches)[order(c(1:31,1:31))]

#Remove duplicate gene ID column and the entrez ID columns
data_methylation_hm450_tumor_normal_matched <- data_methylation_hm450_tumor_normal_matched[,-c(1,3,4)]

```

### 3.2.2 Giving suffixes to duplicate genes
```{r}
# I want to make the gene names into row names, but I cannot because some gene names appear twice.
# So, I will rename them with indexes _1 and _2 and figure out  why they appeared twice later.

#Checking rows of the gene names with duplicates:
checking_dups <- data_methylation_hm450_tumor_normal_matched[data_methylation_hm450_tumor_normal_matched$Hugo_Symbol.1 %in% c("AGER", "CX3CR1", "F2R", "GADL1", "GCOM1", "KLK10", "PALM2AKAP2", "QSOX1", "RCC1"),]

# I see that these are not identical rows - the methylation values are different. So, I will go ahead and add indexes.
checking_dups <- checking_dups[order(checking_dups$Hugo_Symbol.1),]#Sort by gene name

checking_dups <- cbind(rownames(checking_dups), checking_dups[,1]) #Make table of just the gene names and row names of the original file

checking_dups[,2] <- paste(checking_dups[,2],1:2,sep="_") # Add a suffix to the gene names

#Replace the gene names in the T-NM matched file with the suffixed gene names
data_methylation_hm450_tumor_normal_matched[checking_dups[,1],1] <- checking_dups[,2]

#Now that there are no longer duplicates, make the gene names column into the row names and remove the gene names column.
rownames(data_methylation_hm450_tumor_normal_matched) <- data_methylation_hm450_tumor_normal_matched[,1]
data_methylation_hm450_tumor_normal_matched <- data_methylation_hm450_tumor_normal_matched[,2:59]

```

## 3.3 Quality control checks
```{r}

hist(as.matrix(data_methylation_hm450_tumor[3:length(data_methylation_hm450_tumor)]))
max(data_methylation_hm450_tumor[3:length(data_methylation_hm450_tumor)])
min(data_methylation_hm450_tumor[3:length(data_methylation_hm450_tumor)])
boxplot(data_methylation_hm450_tumor[3:length(data_methylation_hm450_tumor)])

hist(as.matrix(data_methylation_hm450_normal[3:length(data_methylation_hm450_normal)]))
boxplot(data_methylation_hm450_normal[3:length(data_methylation_hm450_normal)])

hist(as.matrix(data_methylation_hm450_tumor_normal_matched))
boxplot(data_methylation_hm450_tumor_normal_matched)

# This is definitely not a normal distribution, but the wilcoxon signed-rank test does not assume a normal distribution. However, maybe this could indicate an issue with the original files?

```

## 3.4 Preprocessing (Conversion to M values)
```{r}

# Shorter name for convenience
methyl_beta <- data_methylation_hm450_tumor_normal_matched

# Convert to M values
methyl_M=log2(methyl_beta/(1-methyl_beta))

```


## 3.5 Differential analysis and filtering to FDR < 0.05
```{r}

# Function to remove a tumor-normal pair if one of them has an NA value. Used in the subsequent Wilcox signed-rank test.

remove_NA_pairs <- function(my_data) {
  valid_columns <- c()
  # Iterate through columns in pairs
  for (i in seq(1, ncol(my_data), by = 2)) {
    tumor_col <- my_data[, i]
    normal_col <- my_data[, i+1]
    # Check for NAs in the pair of columns
    if (!any(is.na(tumor_col)) && !any(is.na(normal_col))) {
      valid_columns <- c(valid_columns, i, i+1)
    }
  }
  # Subset the data frame using valid column indices
  result_data <- my_data[, valid_columns]
  return (result_data)
}


### Wilcoxon signed-rank test ###

#Run the Wilcoxon signed-rank test for each gene. 
#Paired=TRUE specifies signed-rank, na.action=na.fail specifies that an error message will be thrown if NAs are still remaining after the filtering step.

pvalues <- sapply(1:nrow(methyl_M),function(i){
     M_values <- methyl_M[i,]
     
     #Remove values from tumor-normal pairs if either of them is NA
     M_values <- remove_NA_pairs(M_values)
     
     #Make group labels to differentiate tumor and normal
     group <- rep(c(1,2),length(M_values))
     data<-cbind.data.frame(gene=as.numeric(t(M_values)),group)
     
     p=wilcox.test(gene~group, data, paired = TRUE, na.action = na.fail)$p.value
     return(p)
   })

#Note that if you use don't use the remove_NA_pairs filtering step, and you use na.action=na.pass, you also don't get any error messages, and it's possible that this also effectively skips over pairs with NAs. I just couldn't find a detailed explanation of how na.pass worked in this case, so I filtered first using my own remove_NA_pairs function.

#Return false discovery rate-corrected P-values
fdr=p.adjust(pvalues,method = "fdr")

#Calculate log2 fold change
tumor_indexes = seq(1, ncol(methyl_M), by = 2)
normal_indexes = seq(2, ncol(methyl_M), by = 2)

tumor_values=methyl_beta[,tumor_indexes]
normal_values=methyl_beta[,normal_indexes]
foldChanges=log2(rowMeans(tumor_values, na.rm = TRUE)/rowMeans(normal_values, na.rm = TRUE))

# Output results to a unified table!
DMeth_LUAD_T_NM_hm450 <-data.frame(log2foldChange=foldChanges, pValues=pvalues, FDR=fdr)
DMeth_LUAD_T_NM_hm450$Gene <- rownames(methyl_beta)
rownames(DMeth_LUAD_T_NM_hm450) <- NULL
DMeth_LUAD_T_NM_hm450=na.omit(DMeth_LUAD_T_NM_hm450) # Remove any NAs

# Check on the duplicated genes, make list of the pairs that had higher FDR values for removal
library(stringr)
DMeth_LUAD_T_NM_hm450_dups_to_rm <- DMeth_LUAD_T_NM_hm450 %>%
  filter(str_detect(Gene, "_")) %>%# Filter to the genes I added a _1 or _2 suffix to
  arrange(., Gene) %>% # Sort by gene name
  mutate(pair_id = rep(1:(n() / 2), each = 2)) %>% # Add a pair ID column
  group_by(., pair_id) %>%
  filter(FDR==max(FDR)) %>% # Get the maximum FDR values of the pairs
  ungroup()

# Remove the less significant duplicate genes 
DMeth_LUAD_T_NM_hm450 <- DMeth_LUAD_T_NM_hm450 %>%
  filter(!(Gene %in% DMeth_LUAD_T_NM_hm450_dups_to_rm$Gene))

#Remove the "_n" suffixes from the remaining genes of the pair
DMeth_LUAD_T_NM_hm450 <- DMeth_LUAD_T_NM_hm450 %>%
  mutate(Gene = str_remove(Gene, "_.*"))

# Keep the genes with FDR<0.05
fdrThres=0.05
DMeth_LUAD_T_NM_hm450_sig <- DMeth_LUAD_T_NM_hm450[DMeth_LUAD_T_NM_hm450$FDR<fdrThres,]

nrow(DMeth_LUAD_T_NM_hm450_sig) # 9868 (2024/11/08 PM)

```

## 3.6 Saving outputs
```{r}
# Change date suffix as appropriate if modifications are made
write.table(DMeth_LUAD_T_NM_hm450_sig, "../2_Outputs/DMeth_LUAD_T_NM_hm450_sig_20241108_PM.txt", sep = '\t')
```

## 3.7 Visualizing DMGs as volcano plot
```{r, fig.width=10, fig.height=6}

log2FC_cutoff3 <- 0.3

v3 <- EnhancedVolcano::EnhancedVolcano(
  toptable = DMeth_LUAD_T_NM_hm450,
  lab = DMeth_LUAD_T_NM_hm450$Gene,
  x = "log2foldChange",
  y = "FDR", 
 # pCutoffCol = 'min_smoothed_fdr',
  xlab = "log2FC",
  ylab = "-log10(FDR)",
  title = "TM DMGs",
  subtitle = paste0("log2FC cutoff: ", log2FC_cutoff3),
  caption = paste0("Total = ", nrow(DMeth_LUAD_T_NM_hm450_sig[abs(DMeth_LUAD_T_NM_hm450_sig$log2foldChange)>log2FC_cutoff3,]), " significant DEGs above log2FC cutoff"),
  col = c("grey30", "mediumpurple2", "royalblue", "orange2"),
  legendPosition = "bottom",
  labSize = 3,
  max.overlaps = 10,
  drawConnectors = TRUE,
  arrowheads = FALSE,
  pCutoff = 0.05,
  FCcutoff = log2FC_cutoff3,
  gridlines.minor = FALSE,
  gridlines.major = FALSE,
  xlim = c(-2, 4),
  ylim = c(0,10)
)

v3

```

## 3.8 Extra checks

```{r}




```


#####

# 4. Differential expression analysis of reference reference "persistent" airway current vs former vs never smoker dataset (A2)

## 4.1 Loading dataset
```{r}
# load series and platform data from GEO

gset <- getGEO("GSE7895", GSEMatrix =TRUE, AnnotGPL=TRUE)
if (length(gset) > 1) idx <- grep("GPL96", attr(gset, "names")) else idx <- 1
gset <- gset[[idx]]

# make proper column names to match toptable 
fvarLabels(gset) <- make.names(fvarLabels(gset))

# group membership for all samples
gsms <- paste0("22222222222222222222200000000000000000000000000000",
               "00000000000000000000000111111111111111111111111111",
               "1111")
sml <- strsplit(gsms, split="")[[1]]

gset <- gset[complete.cases(exprs(gset)), ] # skip missing values

# assign samples to groups and set up design matrix
gs <- factor(sml)
groups <- make.names(c("current_smoker","former_smoker","never_smoker"))
levels(gs) <- groups
gset$group <- gs
design <- model.matrix(~group + 0, gset)
colnames(design) <- levels(gs)

gset <- gset[complete.cases(exprs(gset)), ] # skip missing values

```

## 4.2 Quality control checks

### 4.2.1 Initial checks (histogram, boxplot, PCA)
```{r}

## Make histograms and boxplots to check if the data is log-transformed and needs quantile normalization ##

hist(as.matrix(exprs(gset))) # Values range 1-15, and 1 big peak around 3. 
boxplot(exprs(gset)) # Same range of values, with similar-looking ranges, but not exactly the same
# Narrow range, therefore no log2 normalization needed

exprs(gset) <- normalizeBetweenArrays(exprs(gset))
boxplot(exprs(gset))
# 2024/11/12: I elected to do quantile normalization quantile normalization because this gave me a larger list of "persistent" genes. Could justify that it "better captures the variation between groups" etc

min(exprs(gset))
max(exprs(gset))

## Plot PCA ##
colz <- as.numeric(as.factor(gs)) # Get color values from group
plotMDS(exprs(gset),
        gene.selection = "common",
        main = "PCA for GSE7895",
        col = colz,
        pch = 1
        #labels = gs
        )

legend("topright", legend = levels(as.factor(gs)), 
       fill = unique(colz), 
       title = "Smoking status")
# No separation, all mixed up. This isn't a good look.
```

### 4.2.2 Investigating source of variation
#### Extract and format phenotypic data
```{r}
library(stringr)

phenotypic_data <- pData(gset)  # Extract phenotypic data

# List of column names I want to keep and clean up into usable labels
columns_to_find <- c("characteristics_ch1.1", "group")

# Get the column indexes
indexes <- sapply(columns_to_find, function(col_name) which(names(phenotypic_data) == col_name))
indexes <- unlist(indexes)

phenotypic_data <- phenotypic_data[,c(indexes)]

# Extract Age
phenotypic_data$age <- as.numeric(str_extract(phenotypic_data$characteristics_ch1.1, "(?<=Age:)\\d+"))

# Extract Packyears
phenotypic_data$packyears <- as.numeric(str_extract(phenotypic_data$characteristics_ch1.1, "(?<=Packyears:)\\d+"))

# Extract Time Since Quit Smoking (months)
phenotypic_data$TSQ_months <- as.numeric(str_extract(phenotypic_data$characteristics_ch1.1, "(?<=Time Since Quit Smoking \\(months\\):)\\d+"))

# Delete the original column with the unseparated info
phenotypic_data <- phenotypic_data[,-1]

# Convert the NA values for packyears for never smokers to zero (this makes sense since the never smokers have 0 pack years)
phenotypic_data$packyears[phenotypic_data$group=="never_smoker"] <- 0

# Convert the NA values for TSQ_months to zero for current smokers (again makes sense)
phenotypic_data$TSQ_months[phenotypic_data$group=="current_smoker"] <- 0

# Make column to denote just former smoking status for the linear model
phenotypic_data$former_smoking_status <- as.factor(as.numeric(phenotypic_data$group == "former_smoker"))

# Make column to denote just current smoking status for the linear model
phenotypic_data$current_smoking_status <- as.factor(as.numeric(phenotypic_data$group == "current_smoker"))

# Make column to denote just never smoking status for the linear model
phenotypic_data$never_smoking_status <- as.factor(as.numeric(phenotypic_data$group == "never_smoker"))

```

#### 4.2.3 Plot PCA using other phenotypic data
```{r}


## Plot PCA using age to define color
# Create a gradient color palette (light blue to dark blue)
palette <- colorRampPalette(c("lightblue", "darkblue"))

## Plot PCA of age ##
colz_age <- palette(length(phenotypic_data$age))[rank(phenotypic_data$age)]  # Map ages to gradient colors
plotMDS(exprs(gset),
        gene.selection = "common",
        main = "PCA for GSE7895 (darker blue ~ higher age)",
        col = colz_age,
        pch = 1
        )
# Add a color bar for age
legend("topright", legend = range(phenotypic_data$age), 
       fill = palette(2), 
       title = "Age")
# Does not seem to be an age effect




### Plot PCA of packyears ###

# Excluding packyears of zero (never smokers)
pheno_packyears <- phenotypic_data[phenotypic_data$packyears!=0,]
exprs_packyears <- as.data.frame(exprs(gset)) %>%
  dplyr::select(rownames(pheno_packyears))

colz_packyears <-  palette(length(pheno_packyears$packyears))[rank(pheno_packyears$packyears)] # Map packyears to gradient colors
plotMDS(exprs_packyears,
        gene.selection = "common",
        main = "PCA for GSE7895 (darker blue ~ higher packyears)",
        col = colz_packyears,
        pch = 1
        #labels = gs
        )
# Add a color bar for packyears
legend("topright", legend = range(pheno_packyears$packyears), 
       fill = palette(2), 
       title = "Packyears")
## Does not seem to be packyears effect


### Plot PCA of time since quitting ###
pheno_tsq <- phenotypic_data[!is.na(phenotypic_data$TSQ_months),]
exprs_tsq <- as.data.frame(exprs(gset)) %>%
  dplyr::select(rownames(pheno_tsq))

colz_TSQ <- palette(length(pheno_tsq$TSQ))[rank(pheno_tsq$TSQ)]  # Map packyears to gradient colors
plotMDS(exprs_tsq,
        gene.selection = "common",
        main = "PCA for GSE7895 (darker blue ~ more time since quitting)",
        col = colz_TSQ,
        pch = 1
        #labels = gs
        )
legend("topright", legend = range(pheno_tsq$TSQ), 
       fill = palette(2), 
       title = "TSQ")
## Does not seem to be TSQ effect


```

This is potentially problematic, but I propose that if the genes determined to be "persistent" can differentiate between the groups as expected in PCA, it will be evidence that the results are valid despite the groups not being differentiated by all the genes taken as a whole.

Note that I began trying to do this analysis accounting for pack years and TSQ (see other script), but for now I am just looking at the smoking status comparisons alone.

## 4.3 Differential expression analysis
```{r}

v <- vooma(gset, design, plot=T)
v$genes <- fData(gset) # attach gene annotations


# fit linear model
fit  <- lmFit(v)

# set up contrasts of interest and recalculate model coefficients
#cts <- c(paste(groups[1],"-",groups[2],sep=""), paste(groups[1],"-",groups[3],sep=""), paste(groups[2],"-",groups[3],sep=""))
#cont.matrix <- makeContrasts(contrasts=cts, levels=design)
cont.matrix <- makeContrasts(
  CS_vs_NS = current_smoker - never_smoker,
  FS_vs_NS = former_smoker - never_smoker,
  CS_vs_FS = current_smoker - former_smoker,
  levels = design
)

fit2 <- contrasts.fit(fit, cont.matrix)


# compute statistics and table of top significant genes
fit2 <- eBayes(fit2, proportion = 0.01) # Proportion is "assumed proportion of genes which are differentially expressed"


```

## 4.4 Select "persistent" DEGs, and basic filter (keep lower FDR of duplicates, apply FDR < 0.05 cutoff)
```{r}
library(dplyr)
library(VennDiagram)

## Separate out genes that are DEGS in CS vs NS and FS vs NS

## Note: I have decided not to filter out genes that are significantly different between CS and FS because I realized that doesn't make logical sense.

# summarize test results as "up", "down" or "not expressed"
dT <- decideTests(fit2, adjust.method="fdr", p.value=0.05, lfc=0)

# Venn diagram of results
vennDiagram(dT)

# Select the genes differentially expressed in both CS_vs_NS and FS_vs_NS
dT_persistent <- dT %>%
  as.data.frame(.) %>%
  filter(CS_vs_NS != 0) %>% # Differentially expressed in CS vs NS
  filter(CS_vs_NS == FS_vs_NS)# Differentially expressed, same sign in CS vs FS
nrow(dT_persistent) # 128 genes indeed

# Get the toptable format for all genes
tT <- topTable(fit2, adjust="fdr", sort.by="B", number=Inf) # Inf shows all the significant genes

# Filter to the "persistent" genes
tT_persistent <- tT %>%
  filter(ID %in% rownames(dT_persistent))

# Filter out blanks, keep lower FDR of ties
tT_persistent <- tT_persistent %>%
  filter(Gene.symbol != "") %>% # Remove blank gene symbols
  filter(adj.P.Val <= 0.05) %>% # Remove FDR > 0.05 genes
  group_by(Gene.symbol) %>%
  slice_min(adj.P.Val, with_ties = TRUE) %>% 
  # For probesets mapping to same gene, keep one with lowest FDR. Keep ties for now to check later.
  ungroup()
nrow(tT_persistent)

# Checking for ties
ties <- tT_persistent%>%
  group_by(Gene.symbol) %>%
  filter(n() > 1) %>%
  ungroup()
print(ties)

# As there is a tie with MUCA5 I will remove the MUCA5 probe with an "x" label for cross-reactivity
tT_persistent <- tT_persistent %>% filter (ID != "214303_x_at")

#Pick the columns we care about
GSE7895_persistent_DEGs <- tT_persistent %>%
  dplyr::select(., Gene.symbol, CS_vs_NS, FS_vs_NS, CS_vs_FS, adj.P.Val) %>%
  dplyr::rename(., Gene = Gene.symbol, CS_NS_A2 = CS_vs_NS, FS_NS_A2 = FS_vs_NS, CS_FS_A2 = CS_vs_FS, FDR_A2 = adj.P.Val)

```


## 4.5 Extra checks (PCA for stratification)
```{r}

## Filter exprs to the "persistent" genes
exprs_persistent <- as.data.frame(exprs(gset)) %>%
  filter(rownames(.) %in% tT_persistent$ID)

## Plot PCA ##
colz<- as.numeric(as.factor(gs)) # Get color values from group
plotMDS(exprs_persistent,
        gene.selection = "common",
        main = "PCA for GSE7895 with persistent genes",
        col = colz,
        pch = 1
        #labels = gs
        )

legend("topright", legend = levels(as.factor(gs)), 
       fill = unique(colz), 
       title = "Smoking status")

# You can see more separation happening, but I would expect to see current and former smokers more mixed together, whereas we see former and never smokers more mixed together. Hmm okay, interesting at least.

# Might be good to check on the age, packyears and TSQ here as well?


## Plot PCA of age ##
colz_age <- palette(length(phenotypic_data$age))[rank(phenotypic_data$age)]  # Map ages to gradient colors
plotMDS(exprs_persistent,
        gene.selection = "common",
        main = "PCA for GSE7895 (darker blue ~ higher age)",
        col = colz_age,
        pch = 16
        )
# Add a color bar for age
legend("topright", legend = range(phenotypic_data$age), 
       fill = palette(2), 
       title = "Age")
# Does not seem to be an age effect

### Plot PCA of packyears ###

# Excluding packyears of zero (never smokers)
exprs_persistent_packyears <- as.data.frame(exprs_persistent) %>%
  dplyr::select(rownames(pheno_packyears))

colz_packyears <-  palette(length(pheno_packyears$packyears))[rank(pheno_packyears$packyears)] # Map packyears to gradient colors
plotMDS(exprs_persistent_packyears,
        gene.selection = "common",
        main = "PCA for GSE7895 persistent genes (darker blue ~ higher packyears)",
        col = colz_packyears,
        pch = 16
        #labels = gs
        )
# Add a color bar for packyears
legend("bottomleft", legend = range(pheno_packyears$packyears), 
       fill = palette(2), 
       title = "Packyears")
## Maybe some sort of packyears effect happening, not obviously so


### Plot PCA of time since quitting ###
exprs_persistent_tsq <- as.data.frame(exprs_persistent) %>%
  dplyr::select(rownames(pheno_tsq))

colz_TSQ <- palette(length(pheno_tsq$TSQ))[rank(pheno_tsq$TSQ)]  # Map packyears to gradient colors
plotMDS(exprs_persistent_tsq ,
        gene.selection = "common",
        main = "PCA for GSE7895 persistent genes (darker blue ~ more months since quitting)",
        col = colz_TSQ,
        pch = 16
        #labels = gs
        )
legend("bottomleft", legend = range(pheno_tsq$TSQ), 
       fill = palette(2), 
       title = "TSQ")
## Maybe some TSQ effect but not super obvious

```

#####

# 5. Comparing and filtering A1, TE, TM, and A2 to generate "linked genes" and "linked persistent genes" lists

## 5.1 Applying log2FC cutoffs
```{r}

### Testing log2FC cutoffs ###

# A1 DEGs
log2Thres_A1=0.2
nrow(GSE63127_CS_NS_GEO2R_limma_sig[abs(GSE63127_CS_NS_GEO2R_limma_sig$logFC)>log2Thres_A1,])

# TCGA-LUAD DEGs
log2Thres_TE=1
nrow(DGE_LUAD_T_NM_signed_rank_sig[abs(DGE_LUAD_T_NM_signed_rank_sig$log2foldChange)>log2Thres_TE,])

# TCGA-LUAD DMGs
log2Thres_TM=0.3
nrow(DMeth_LUAD_T_NM_hm450_sig[abs(DMeth_LUAD_T_NM_hm450_sig$log2foldChange)>log2Thres_TM,])

## Notes on number of linked genes after filtering:
# 0, 0, 0 => 950 genes
# 0.2, 1, 0.3 => 143 genes
# 0.5, 2, 0.5 => 14 genes
# 0.5, 1, 0.5 => 26 genes (but still good correlation across board unlike with other options)


### Applying log2FC cutoffs and formatting consistently for merge ###

GSE63127_CS_NS_GEO2R_limma_sig_cutoff <- GSE63127_CS_NS_GEO2R_limma_sig %>%
  filter(abs(logFC)>log2Thres_A1) %>%
  dplyr::rename(Gene = Gene.symbol, FDR_A1 = adj.P.Val, log2FC_A1 = logFC) %>%
  dplyr::select(., Gene, FDR_A1, log2FC_A1)

DGE_LUAD_T_NM_signed_rank_sig_cutoff <- DGE_LUAD_T_NM_signed_rank_sig %>%
  filter(abs(log2foldChange)>log2Thres_TE) %>%
  dplyr::rename(., FDR_TE = FDR, log2FC_TE = log2foldChange) %>%
  dplyr::select(., Gene, FDR_TE, log2FC_TE)

DMeth_LUAD_T_NM_hm450_sig_cutoff <- DMeth_LUAD_T_NM_hm450_sig %>%
  filter(abs(log2foldChange)>log2Thres_TM) %>%
  dplyr::rename(., FDR_TM = FDR, log2FC_TM = log2foldChange) %>%
  dplyr::select(., Gene, FDR_TM, log2FC_TM)


```

## 5.2 Filtering by dataset intersection

### 5.2.1 Intersection of A1 and TE DEGs
```{r}
## Merge the lists
A1_TE_merged_DEGs <- GSE63127_CS_NS_GEO2R_limma_sig_cutoff %>%
  inner_join(., DGE_LUAD_T_NM_signed_rank_sig_cutoff, by = "Gene") %>%
  filter(sign(log2FC_A1)==sign(log2FC_TE)) # Filter to genes with same signs
  
nrow(A1_TE_merged_DEGs)

```

### 5.2.2 Intersection of A1/TE DEGs with TM DMGs
```{r}
## Merge the lists
A1_TE_TM_linked_genes <- A1_TE_merged_DEGs %>%
  inner_join(., DMeth_LUAD_T_NM_hm450_sig_cutoff, by = "Gene") %>%
  filter(sign(log2FC_A1)!=sign(log2FC_TM)) # Filter to genes with opposite sign
  
nrow(A1_TE_TM_linked_genes)

```

Note: Maybe this should incorporate a Spearman correlation filter? But for this I would need to pair samples across the tumor datasets I think, at the expression/M value level. So you can get an idea of the broader correlation with the log2FC values but to apply it more broadly you need the initial tables instead.

### 5.2.3 Visualizing Spearman correlations of log2FC values
```{r}
## Visualizing Spearman correlations
library(GGally)
ggpairs(A1_TE_TM_linked_genes[, c("log2FC_A1", "log2FC_TE", "log2FC_TM")],
  upper = list(continuous = wrap("cor", method = "spearman")),
  lower = list(continuous = "points", combo = "facethist", discrete = "facetbar", na ="na"),
  diag = list(continuous = "densityDiag", discrete = "barDiag", na = "naDiag"))

```

### 5.2.4 Visualizing multiple linear regression of the log2FC values
```{r}
mlr_airway_model <- lm(log2FC_A1 ~ log2FC_TE + log2FC_TM, data = A1_TE_TM_linked_genes)
summary(mlr_airway_model)


library(scatterplot3d)
s3d <- scatterplot3d(x = A1_TE_TM_linked_genes$log2FC_A1, 
              y = A1_TE_TM_linked_genes$log2FC_TE, 
              z = A1_TE_TM_linked_genes$log2FC_TM,
              main="Plotting airway expression vs. tumor expression vs. tumor methylation",
              xlab = "log2FC(TE)",
              ylab = "log2FC(TM)",
              zlab = "log2FC(A1)",
              pch = 19,
              #color = colors_3d, # getting color values from methylation sign
              color = "steelblue",
              labels = A1_TE_TM_linked_genes$Gene,
              type = "h",
              #highlight.3d = TRUE, 
              angle = 60
              )
s3d$plane3d(mlr_airway_model) # Add a plane based on the multiple linear regression model

```


## 5.3 Comparing and filtering A2 and "linked" genes to give "persistent linked genes"

### 5.3.1 Applying log2FC cutoffs
```{r}
# For now, no cutoffs
```

### 5.3.2 Filtering by dataset intersection
```{r}

A1_TE_TM_A2_persistent_linked_genes <- A1_TE_TM_linked_genes %>%
  dplyr::inner_join(., GSE7895_persistent_DEGs, by = "Gene") %>%
  dplyr::filter(sign(log2FC_A1) == sign(CS_NS_A2)) # Ensure signs are the same between A1 and A2 CS vs NS

A1_TE_TM_A2_persistent_linked_genes

## Recording results based on cutoffs
## 0.5,1,0.5,0 => 1 (NQO1)
## 0,0,0,0 => 27
## 0.2, 1, 0.3 => 10

```
### 5.3.3 Additional checks (correlation of log2FCs in A1 and A2)
```{r}
cor.test(A1_TE_TM_A2_persistent_linked_genes$log2FC_A1, y = A1_TE_TM_A2_persistent_linked_genes$CS_NS_A2, use = "everything",
    method = "spearman")

ggplot(A1_TE_TM_A2_persistent_linked_genes, aes(x = log2FC_A1, y = CS_NS_A2), 
      geom_point(color = "blue", size = 3) +                # Scatter points
      geom_smooth(method = "lm", se = FALSE, color = "red") + # Add a trend line
    
ggplot(A1_TE_TM_A2_persistent_linked_genes, aes(x = log2FC_A1, y = CS_NS_A2)) +
  geom_point(color = "blue", size = 3) +                # Scatter points
  geom_smooth(method = "lm", se = FALSE, color = "black") + # Add a trend line +
  theme_minimal()
```


## Saving files
```{r}
# write.table(A1_TE_TM_linked_genes, "../2_Outputs/A1_TE_TM_linked_genes_nocutoffs_20241112.txt", sep = '\t')
# 
# write.table(A1_TE_TM_A2_persistent_linked_genes, "../2_Outputs/A1_TE_TM_A2_persistent_linked_genes_nocutoffs_20241112.txt", sep = '\t')

```


